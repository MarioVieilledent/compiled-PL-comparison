# Comparison of compiled programming languages in terms of readability and executable size

![GitHub language count](https://img.shields.io/github/languages/count/MarioVieilledent/compiled-PL-comparison)

> All source code has been generated by **chatGPT**. Not even a joke, I didn't code a single line of code here.

| Language | Size of exe in KB | Lines of code | Compilation                 |
| -------- | ----------------- | ------------- | --------------------------- |
| C        | 17                | 59            | `gcc`                       |
| Rust     | 176               | 40            | `cargo build --release`     |
| Go       | 4627              | 21            | `go buimd -ldflags "-s -w"` |

## Personal analysis

Go is by far the easiest code to get with, also it has the cleanest syntax enhanced by fmt.

Though Go program compiled size is **272 times heavier than C**, and 26 times heavier than rust, I think it is still worth for the benefit of the cleaner syntax.

Rust has a totally different approach and is definitely not easy to get with. But it comes with a pretty small runtime and should replace C nowadays.

## Go

```go
package main

import (
	"encoding/json"
	"net/http"
)

type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		person := Person{Name: "Alice", Age: 30}
		json.NewEncoder(w).Encode(person)
	})

	http.ListenAndServe(":1200", nil)
}

```

## Rust

```rust
use serde::Serialize;
use serde_json;
use std::io::Write;
use std::net::TcpListener;

#[derive(Debug, Serialize)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
    };

    let listener = TcpListener::bind("127.0.0.1:1200").unwrap();
    println!("Serveur HTTP en écoute sur le port 1200");

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                println!("Connexion établie !");

                let response = format!(
                    "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{}\r\n",
                    serde_json::to_string(&person).unwrap()
                );

                stream.write(response.as_bytes()).unwrap();
                stream.flush().unwrap();
            }
            Err(e) => {
                println!("Erreur lors de l'établissement de la connexion : {}", e);
            }
        }
    }
}

```

## C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define PORT 1200
#define BUFFER_SIZE 1024

typedef struct {
    char name[32];
    int age;
} Person;

int main() {
    int server_fd, new_socket, valread;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};

    Person person = {"Alice", 30};
    char response[BUFFER_SIZE] = {0};
    sprintf(response, "{\"name\":\"%s\",\"age\":%d}", person.name, person.age);

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Erreur de création de socket");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("Erreur de configuration de socket");
        exit(EXIT_FAILURE);
    }
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("Erreur d'attachement du socket");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 3) < 0) {
        perror("Erreur d'écoute du socket");
        exit(EXIT_FAILURE);
    }

    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("Erreur d'acceptation de la connexion");
        exit(EXIT_FAILURE);
    }

    send(new_socket, response, strlen(response), 0);
    printf("Réponse envoyée: %s\n", response);

    return 0;
}

```
